# Artificial Intelligence - Report

**Name:** Siebe Mees

**Student number:** s0222485


## (Un)Informed Search – Discuss Heuristic

This heuristic estimates the remaining cost to collect all food by combining two metrics:

1. **The distance to the nearest food:**  
   Before Pacman can start clearing all the food, he first has to reach one.  
   So we look at how far the closest food is, measured by the *real path* Pacman must take through the maze (not just straight-line distance).

2. **The Minimum Spanning Tree (MST) cost over all remaining foods (using Prim’s algorithm):**  
   Once Pacman is near the food area, he’ll still have to travel between all the food dots to eat them.  
   The cheapest way to connect all those dots, without worrying about the exact order, is what a Minimum Spanning Tree (MST) represents.

_Intuitive explanation: It works like this: you start from one node, then look for the cheapest neighbor to connect to. From there, you keep exploring — each time choosing the cheapest possible new connection from the nodes you’ve already added. You repeat this process until all nodes are connected, without forming any loops._

> h(state) = (1. distance from Pacman to the nearest food) + (2. Minimum Spanning Tree (MST) cost over all remaining foods)

- **Admissibility:**  
  The heuristic never overestimates because Pacman must at least reach one food and then travel enough distance to connect all remaining foods.  
  The MST + nearest food gives the smallest possible total distance for that.

- **Consistency:**  
  The estimated cost at the current state can’t drop by more than the actual cost of moving to a neighbor.  
  Each move can only make Pacman a little closer to the goal, never more than the cost of that move itself.  
  The “cheapest connection network” (MST) never suddenly becomes longer when you move, and the nearest-food distance can only shrink gradually.  

**Note:** I found out that the heuristic I used during the exercises for Question 4 is inconsistent.


## Adversarial Search - Discuss evaluation function

Our **evaluation function** takes the following into account:

- **Avoid ghosts:**  
  We look at where the ghosts are and compute their distances.  
  - If a ghost is **scared**, we approach it, increasing the score proportionally (taking the timer into account responsively).  
  - If a ghost is **not scared**, we stay away, decreasing the score proportionally to how close the ghost is (the closer it is, the stronger the penalty).  
  - If a ghost is at the same position as Pacman (distance = 0), we immediately return `-∞` to avoid suicidal moves.

- **Eat food:**  
  Pacman is rewarded for being close to food pellets. The closer he is to the nearest food, the higher the score.

- **Eat capsules:**  
  Similar to food, Pacman is rewarded for being closer to power capsules.

- **Trade-off — Eating food vs. chasing ghosts:**  
  We compute which option will yield a higher overall score and prioritize that action. If a scared ghost is reachable within the remaining timer window, chasing it is more profitable; otherwise, Pacman focuses on clearing food efficiently.

---

*Markdown formatting automatically generated by OpenAI’s ChatGPT.*